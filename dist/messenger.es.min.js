export let messenger=parent.messenger;if(window===parent&&!window.messenger){const e=()=>Math.random().toString(36).slice(2),t=e(),s={},n={},o={},a=e=>e instanceof Promise?e:Promise.resolve(e),i=queueMicrotask||(e=>Promise.resolve().then(e));window.addEventListener("message",e=>{if(e.origin!==location.origin||!e.data||e.data.channel!==t)return;e.stopImmediatePropagation();const r=e.data.payload,c=r.id||"",d=r.topic,l=r.data,m=r.timeout||0;switch(e.data.method){case"send":const t=o[c];s[d]?(()=>m>0?Promise.race([a(s[d](l)),new Promise((e,t)=>setTimeout(t,m))]):a(s[d](l)))().then(e=>t.resolve(e)).catch(e=>t.reject(e)):t.reject(),delete o[c];break;case"publish":for(const e of n[d]||[])i(()=>e(l))}},{capture:!0,passive:!0}),messenger=new class{send(s,n,a=0){return new Promise((i,r)=>{const c=e(),d={id:c,topic:s,data:n,timeout:a};o[c]={resolve:i,reject:r},parent.postMessage({channel:t,method:"send",payload:d},location.origin)})}bind(e,t){if(!s[e])return s[e]=t,()=>delete s[e]}publish(e,s){parent.postMessage({channel:t,method:"publish",payload:{topic:e,data:s}},location.origin)}subscribe(e,t){const s=n[e]=n[e]||[];return s[s.length]=t,()=>{const o=s.indexOf(t);~o&&(s.splice(o,1),s.length||delete n[e])}}},window.messenger=messenger}